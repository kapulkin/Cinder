<html>
<head>
	<title>OpenGL in Cinder 0.9</title>
	<meta name="keywords" content="guide">
	<link rel="stylesheet" href="../../_assets/css/foundation.css">
	<link rel="stylesheet" href="../../_assets/css/cinder_docs.css">
	<link rel="stylesheet" href="../../_assets/css/prism.css">
</head>
<body id="guide-contents" >
<h1>OpenGL in Cinder 0.9</h1>
<p>
This guide is written with users of previous versions of Cinder in mind, and is meant to aid in the transition to Cinder&rsquo;s new OpenGL API in version 0.9.0.
</p>

<p>
OpenGL has evolved considerably in recent versions. And with the introduction of Core Profile  in OpenGL 3.2 (and parallel changes in OpenGL ES 2), much of the functionality of previous versions has been removed entirely. Most prominent was the removal of the fixed function pipeline,  which gave way to the fully programmable pipeline . This change allows OpenGL to more closely map to the underlying hardware, and is a significant improvement with respect to power and performance. However some of the simpler techniques for interacting with GL in previous versions are no longer available.
</p>

<p>
With version 0.9.0, Cinder attempts to expose this new power, while still maintaining a relatively easy-to-use API.  While this document is not an exhaustive tutorial on the new API, it does cover the core concepts, and should be supplemented with a look at the sample code found in <a href="https://github.com/cinder/Cinder/tree/master/samples/_opengl">samples/_opengl</a>.
</p>

<h4>What&rsquo;s Changed in OpenGL Itself?</h4>
<p>
Quite a bit of functionality was removed with OpenGL Core Profile. One of the most significant changes is that OpenGL no longer provides a way to draw without a GLSL program (informally called a shader ). Furthermore, immediate mode - functions like <code>glBegin()</code>, <code>glVertex()</code> and <code>glEnd()</code> - are no longer available. OpenGL also no longer has the notion of a vertex normal, a color, or similar. Instead, all such data is generic per-vertex data which the user supplies in the form of GLSL attributes. This vertex data is also only made available to GLSL programs via generic buffers of vertex data called Vertex Buffer Objects  (VBOs). Additionally, OpenGL no longer has the concept of the <code>GL_MODELVIEW</code> or <code>GL_PROJECTION</code> matrices. Similar to generic attributes, such data are the responsibility of the programmer to maintain and to pass to her shaders via generic GLSL uniform variables. Much of the global state in previous versions of GL is gone entirely as well. For example, texturing is no longer enabled via <code>glEnable( GL_TEXTURE_2D )</code>. Such state is no longer state at all, but is simply implemented or not implemented in the currently bound GLSL program.
</p>

<h4>What&rsquo;s Changed in Cinder?</h4>

<p>
As you might imagine, Cinder has changed quite a bit too in order to embrace this new philosophy in OpenGL. We&rsquo;ve attempted to create an API that captures the power of this new way of working, but have also tried to maintain abstractions that are much simpler to use than pure GL. While some things have necessarily become more complex, we believe the benefits easily outweigh the costs, and that you&rsquo;ll find this new approach to be not only more capable but even more enjoyable to use.
</p>

<h3>Getting Started</h3>

<p>
In previous versions of Cinder, the easiest way to draw was to use the GL convenience methods, like <ci>gl::drawSolidCircle()</ci>. This is still true in 0.9.0, but with a minor caveat. As mentioned previously, OpenGL now requires a shader to be bound, so we&rsquo;ll need to provide it one. Cinder offers a class called <ci>gl::ShaderDef</ci> for easily generating common shaders. To draw a solid white circle, this is the code:
</p>

<pre class="lang-cpp"><code>
gl::bindStockShader( gl::ShaderDef().color() );
gl::drawSolidCircle( vec2( 100, 100 ), 50 );
</code></pre>

<p>
As in previous versions, <ci>gl::drawSolidCircle()</ci> takes a center point and a radius. However the preceding line is new. <ci>gl::bindStockShader()</ci> accepts a <ci>gl::ShaderDef</ci> and either generates a shader (a <ci>gl::GlslProg</ci>) as is necessary. It also caches these <ci>gl::GlslProg</ci>&rsquo;s to avoid unnecessary compilation. In this example, we&rsquo;re using <ci dox="gl::ShaderDef::color">.color()</ci> on the <ci dox="gl::ShaderDef">ShaderDef</ci> in order to request that the current color be used, which defaults to white.
</p>

<p>
To make our circle red we use the same function we&rsquo;d use in previous versions, <ci>gl::color()</ci>:
</p>

<pre class="lang-cpp"><code>
gl::bindStockShader( gl::ShaderDef().color() );
gl::color( 1, 0, 0 );
gl::drawSolidCircle( vec2( 100, 100 ), 50 );
</code></pre>

<p>
Essentially all GL convenience methods (<ci>gl::drawCube()</ci>, <ci>gl::drawSphere()</ci>, <ci>gl::drawSolidRect()</ci>, etc) still function in 0.9.0, and there are new convenience methods as well. However, using a GL convenience method should always be considered the slow path . They&rsquo;re fine for initial development or code that is not performance-sensitive, but the techniques we&rsquo;ll discuss next should always be preferred when speed counts.
</p>

<h4>Batches</h4>
<p>
<ci>gl::Batch</ci> is the fast path in Cinder 0.9.0 for typical cases. An instance of gl::Batch represents the combination of geometry and an associated shader. To get started, let&rsquo;s optimize our previous use of the convenience method <ci>gl::drawSolidCircle()</ci>.
</p>

<pre class="lang-cpp"><code>
class MyApp : public App {
    &hellip;
    gl::BatchRef    mCircleBatch;
};

void MyApp::setup()
{
    gl::GlslProgRef solidShader = gl::getStockShader( gl::ShaderDef().color() );
    mCircleBatch = gl::Batch::create( geom::Circle().center( vec2( 100, 100 ) ).radius( 50 ), solidShader );
}

void MyApp::draw()
{
    gl::clear();
    gl::color( 1, 0, 0 );
    mCircleBatch-&gt;draw();
}
</code></pre>

<p>
This code touches on several different new concepts. First, we&rsquo;re using our <ci dox="gl::ShaderDef">ShaderDef</ci> slightly differently. Rather than binding it using <ci>gl::bindStockShader()</ci>, we&rsquo;re using <ci>gl::getStockShader()</ci>, which returns a proper <ci dox="gl::GlslProgRef">GlslProgRef</ci> based on a <ci>gl::ShaderDef</ci>. Next, we construct a <ci>gl::Batch</ci>. The constructor (called via <ci dox="gl::GlslProg::create">create()</ci>) accepts geometry as the first parameter and a <ci>gl::GlslProgRef</ci> as the second parameter - in our case the one we just generated with <ci>gl::getStockShader()</ci>.
</p>

<p>
Let&rsquo;s look at the first parameter to our Batch construction, the geometry portion: <code>geom::Circle().center( 100, 100 ).radius( 50 )</code>. This uses <ci>geom::Circle</ci>, which is one of many classes provided with Cinder that can be used to create geometry. Other examples include <ci>geom::Sphere</ci>, <ci>geom::Teapot</ci>, <ci>geom::WireCone</ci>, and many others. The pairing of one of these <ci>geom::Source</ci>s (or another source of geometry, such as a <ci>TriMesh</ci> or a <ci dox="gl::VboMesh">VboMesh</ci>) with a shader (<ci dox="gl::GlslProg">GlslProg</ci>) is expressed with a <ci>gl::Batch</ci>.
</p>

<p>
To draw a <ci>gl::Batch</ci> we simply use its <ci dox="gl::Batch::draw">draw()</ci> member method. Notice that we still set the color with <ci>gl::color()</ci>. Cinder &ldquo;knows&rdquo; that the <ci>gl::Batch</ci>&rsquo;s shader requires the current color, and it passes it along in a uniform automatically. We&rsquo;ll look at how that machinery works later.
</p>

<h3>Transformations</h3>

<p>
In previous versions of OpenGL (and Cinder), there was a global stack of two matrices, one for the ModelView matrix, and one for the Projection matrix. Users manipulated these stacks with functions like <code>glTranslatef()</code> or in Cinder, <ci>gl::translate()</ci>. In modern GL these stacks are removed entirely. However Cinder still provides this useful functionality through the same methods - <ci>gl::translate()</ci>, <ci>gl::scale()</ci>, <ci>gl::rotate()</ci>, etc.
</p>

<p>
One key difference is that Cinder now separates the Model and View matrices. Calls to <ci>gl::translate()</ci> et al manipulate the active Model matrix; there is no longer the concept of the matrix mode (formerly manipulated with the now defunct <code>glMatrixMode()</code>). Here&rsquo;s an example; we can adapt the code above to draw a number of circles in a circular arrangement, all using the same <ci>gl::Batch</ci>.
</p>

<p>
First a modification to our setup() routine to create our <ci>geom::Circle</ci> at the default origin, rather than at <code>vec2( 100, 100 )</code> as previously. We&rsquo;ll also shrink the radius a bit:
</p>

<pre class="lang-cpp"><code>
mCircleBatch = gl::Batch::create( geom::Circle().radius( 30 ), solidShader );
</code></pre>

<p>
And now in draw(), we&rsquo;ll do the following:
</p>

<pre class="lang-cpp"><code>
void MyApp::draw()
{
  gl::clear();

  for( float angle = 0; angle &lt; 2 * M_PI; angle += 0.2f ) {
    gl::pushModelMatrix();
    gl::translate( getWindowCenter() + 200.0f * vec2( sin( angle ), cos( angle ) ) );
    gl::color( Color( CM_HSV, angle / (2 * M_PI), 1, 1 ) );
    mCircleBatch-&gt;draw();
    gl::popModelMatrix();
}
</code></pre>

<p>
Let&rsquo;s look at this routine. A for-loop iterates from 0 to 2 pi radians. Within the loop we preserve the current Model matrix using <ci>gl::pushModelMatrix()</ci>. We then translate the current Model transformation to the window center plus a bit of trigonometry to arrange the circles&rsquo; centers in a larger circle of radius 200. Next we set the current color using HSV color, and then draw our <ci>gl::Batch</ci>. Note that this draw command is &ldquo;aware&rdquo; of the current Model matrix (not to mention View and Projection) as well as the current color automatically. Finally, we restore the Model matrix to what it was previous to this iteration of the loop, using <ci>gl::popModelMatrix()</ci>.
</p>

<img src="circle_circle.png" />
<br />

<h3>Scoped Utilities and State</h3>
<p>
In Cinder 0.9.0 you&rsquo;ll see a number of classes which begin with gl::Scoped in the name. Examples include <ci>gl::ScopedModelMatrix</ci>, <ci>gl::ScopedColor</ci>, and <ci>gl::ScopedTextureBind</ci>. While there are other ways to achieve the same thing, these classes are efficient and easy to use. They are designed in accordance with <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, preserving a given piece of state on instantiation and restoring it on destruction. As an example, let&rsquo;s rework the previous for-loop to use a <ci>gl::ScopedModelMatrix</ci>:
</p>

<pre class="lang-cpp"><code>
 for( float angle = 0; angle &lt; 2 * M_PI; angle += 0.2f ) {
    gl::ScopedModelMatrix scpModelMtx;
    gl::translate( getWindowCenter() + 200.0f * vec2( sin( angle ), cos( angle ) ) );
    gl::color( Color( CM_HSV, angle / (2 * M_PI), 1, 1 ) );
    mCircleBatch-&gt;draw();
  }
</code></pre>

<p>
In this example, creating our variable <code>scpModelMtx</code> preserves the Model matrix at its point of instantiation. We then manipulate the Model matrix using <ci>gl::translate()</ci>. And when the destructor for scpModelMtx  fires at the end of the loop iteration, it will restore the Model matrix to its value when <code>scpModelMtx</code> was instantiated.
</p>

<p>
Additionally, it&rsquo;s worth noting that Cinder now caches virtually all state in a class called <ci>gl::Context</ci>. This allows Cinder to save and restore state quickly without querying GL for the active values. As a result, it&rsquo;s safe and fast to use these <em><code>gl::Scoped</code></em> family of classes for preserving state.
</p>

<h3>Writing Custom Shaders</h3>
<p>
While <ci>gl::ShaderDef</ci> is helpful for basic shaders (in addition to <ci dox="gl::ShaderDef::color">color()</ci>, it supports <ci dox="gl::ShaderDef::texture">texture()</ci> and <ci dox="gl::ShaderDef::lambert">lambert()</ci>) it&rsquo;s common to write your own GLSL. Let&rsquo;s look at an example of how to do that.
</p>

<p>
We&rsquo;ll keep the same circle example, and write a shader that takes the place of our <ci dox="gl::ShaderDef">gl::ShaderDef</ci>-created version. For the purposes of this example, we&rsquo;ll make use of the <code>CI_GLSL()</code> macro, which allows writing GLSL code inline. Our setup routine looks like this now:
</p>

<pre class="lang-cpp"><code>
void MyApp::setup()
{
  gl::GlslProgRef solidShader = gl::GlslProg::create(
  // vertex code
  CI_GLSL( 150,
       uniform mat4        ciModelViewProjection;
       in vec4                ciPosition;
       in vec4                ciColor;
       out lowp vec4        Color;

       void main( void )
       {
         gl_Position        = ciModelViewProjection * ciPosition;
         Color              = ciColor;
       }
     ),
     // fragment code
     CI_GLSL( 150,
       in vec4          Color;
       out vec4         oColor;

       void main( void )
       {
         oColor = Color;
       }
     ) );

     mCircleBatch = gl::Batch::create( geom::Circle().radius( 30 ), solidShader );
}
</code></pre>

<p>
And just to reiterate, if we had written files named say, <em>solidColor.vert</em> and <em>solidColor.frag</em> and stored them as files in our assets  directory - a more common workflow - we&rsquo;d see a line like this instead of the <code>CI_GLSL</code> macros:
</p>

<pre class="lang-cpp"><code>
GlslProgRef solidShader = gl::GlslProg::create( loadAsset( &ldquo;solidColor.vert&rdquo; ), loadAsset( &ldquo;solidColor.frag&rdquo; ) );
</code></pre>

<p>
Looking at our GLSL code above, you&rsquo;ll see a few distinctive things. First, we have both uniforms and attributes with the prefix <code>ci</code> - <code>ciModelViewProjection</code>, as well as attributes <code>ciPosition</code> and <code>ciColor</code>. These names are special, and serve as signals to Cinder to automatically fill in their values appropriately. As you might imagine, <code>ciModelViewProjection</code> is equivalent to the current Model, View and Projection matrices concatenated into a single <ci>mat4</ci>. If you have been writing GLSL shaders in prior OpenGL versions, you likely used the now defunct <code>gl_ModelViewProjectionMatrix</code> variable for this.
</p>

<p>
Similarly, there are automatically recognized vertex attributes; in the example above they are <code>ciPosition</code> and <code>ciColor</code>. In the case of <code>ciPosition</code>, this attribute is automatically supplied by our <ci>geom::Circle</ci>. <code>ciColor</code> is similar but has a unique caveat. If our <ci>geom::Source</ci> had supplied a color, the shader would have used it. However Cinder automatically supplies the global current color (set via <ci>gl::color()</ci>) in the absence of a per-vertex color. As an experiment, let&rsquo;s try slightly different geometry that does supply per-vertex color. If we change the <ci>gl::Batch</ci> assignment in <code>setup()</code> out like this:
</p>

<pre class="lang-cpp"><code>
ColorAf green( 0, 1, 0 ), blue( 0, 0, 1 );
mBatch = gl::Batch::create( geom::Rect().colors( green, green, blue, blue ).
                        rect( Rectf( -15, -10, 15, 10 ) ), solidShader );
</code></pre>

<p>
We see this:
</p>
<img src="rect_circle.png" />
<br />

<p>
Here we see the global color is ignored as <ci>geom::Rect</ci> has generated per-vertex colors upon our request. For the curious, this automatic variable uploading occurs in the <ci>gl::Batch::draw()</ci> call, and it can be invoked manually in advanced usage scenarios. Furthermore, there are mechanisms for manually configuring the mapping to attributes and uniforms in <ci dox="gl::GlslProg::Format">GlslProg::Format</ci> for users that have some reason to use a non - default configuration.
</p>

<h3>Conclusion</h3>

<p>
The OpenGL API in Cinder 0.9.0 is quite deep - much more so than can be captured in this post. However hopefully this serves as enough background to dig into the samples, which are the best place to learn until we have more thorough documentation.
</p>

<script src="../../_assets/js/prism.js" type="text/javascript"></script>
</body>
</html>